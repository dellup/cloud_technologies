# DevOps Лабораторная работа №2 с * - Docker Compose
## Техническое задание лабораторной 

1. Написать “плохой” Docker Compose файл, в котором есть не менее трех “bad practices” по их написанию.
2. Написать “хороший” Docker Compose файл, в котором эти плохие практики исправлены.
3. В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат.
4. После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции.

## Чему мне предстоит научиться в процессе работы?

Для себя разработал ряд небольших целей.
1. Создать два контейнера: веб-сервер (например, Nginx) и базу данных (PostgreSQL).
2. Настроить их так, чтобы они работали в отдельных, изолированных сетях.
3. Проверить, что контейнеры не могут напрямую взаимодействовать между собой.
4. Проанализировать, как изоляция влияет на безопасность и работу приложений.
5. Отработать практики написания.

Это важно и пригодится в профессиональной деятельности, ведь если я научусь работать с сетевыми изоляциями, это поможет мне избежать утечек данных и нежелательного взаимодействия между сервисами. Да и в принципе, умение работать с Docker-сетями важно для DevOps-инженеров и разработчиков.

## Какая система используется при работе?

Изначально были мысли воспользоваться Virtual Box и выполнить работу на дистрибутиве Arch Linux. Вернувшись после лечения из дурки было принято волевое решение использовать MacOS. 

## Пункт 1-ый: “Плохой” Docker compose

<image src="плохой докер.jpg" alt="Описание изображения">;

Файл написан халтурно, по настоящему плохой. Хуже, наверно, уже некуда. Даже когда его вообще нет уже лучше, чем это. В чем же проблема?
- Во-первых, проблема с монтированием в volumes: Здесь монтируется директория /data из локальной системы. Если этой директории нет, возникнет ошибка, а если есть — она может содержать нежелательные данные, которые затрут содержимое контейнера.
    
- Во вторых, использование переменной NODE_ENV в сервисе app: Она не используется Nginx, а если что-то не используется в коде - это мусор. Мусор никто не любит, его все выбрасывают.
    
- В третьих, присутствует использование depends_on: данный ключ не гарантирует порядок готовности контейнеров, только их запуск. База данных db может ещё не быть готова, когда стартует app.

## Пункт 2-ой: “Хороший” Docker compose

<image src="хороший докер.jpg" alt="Описание изображения">;

Очень, очень хороший контейнер! Вежлив, правдив, скромен, добр, слушает папу (меня), каждое утро делает зарядку. Характер мягкий, не женат.

_Исправления:_

- Правим директории: Вместо монтирования системной директории /data, создаём локальную папку в проекте (./nginx-data). Это упрощает повторяемость и защищает локальные данные. Добавляем :ro (только для чтения), чтобы предотвратить изменения данных в контейнере.
- Убрана ненужная переменная окружения NODE_ENV: Она не влияет на работу Nginx, поэтому её удаление уменьшает шум.
- Использование healthcheck вместо depends_on: Проверяется, готова ли база данных (через команду pg_isready), и приложение запускается только после её готовности.
- Добавлены две отдельные сети isolated_app и isolated_db, что предотвращает взаимодействие между контейнерами.
- Сервис app подключён только к isolated_app, а db — только к isolated_db.
- Теперь контейнеры остаются изолированными, хотя всё ещё работают корректно в своих задачах.

## Дальнейший ход работы

<image src="pyat.jpg">;
<image src="шесть.jpg">;

Когда значительная часть работы позади, берёмся за самое интересное! Во-первых, поработаем с Nginx. Создадим отдельную папку и закинем туда HTML файл, котоырй будет выводить при подключении в браузере приятные слова для всех Петербуржцев. Также мы поднимем хороший докер контейнер, следим за руками:

1. Запускаем докер-любимку с помощью docker-compose -f docker-compose.good.yml up
2. Заходим на сайт по адресу http://localhost:8080 и что же мы видим?
3. Останавливаем контейнер после того, как мы увидели фразу. Используем docker-compose -f docker-compose.good.yml up.

Спойлер: вот что мы видели

<image src="html.jpg">;
<image src="website.jpg">;

Перейдём к следующему пункту плана.

## Изоляция. Проверка работы.

1. Снова поднимаем контейнер docker-compose -f docker-compose.good.yml up.
<image src="111.jpg">;
2. Прописываем команду docker network ls чтобы убедиться, что сети isolated_app и isolated_db существуют.
<image src="ls.jpg">;
3. Используем docker ps и ищем ID контейнера app.
<image src="docker network ls.jpg">;
4. Аккуратно входим внутрь, никого не разбудив (сейчас 3:56 ночи). Используем docker exec -it <тут айди> sh. ФОТО
5. После этого пробуем ping. Фото выше.
6. Убеждаемся, что он невозможен, что подтверждает изоляцию. Опять фото выше.
7. Так же тихо выходим, используя exit. Снова фото выше.

## Итог проделанной работы

Потрудились славно, создали два контейнера (веб-сервер и базу данных) и настроили их так, чтобы они находились в изолированных сетях. Это позволит обеспечить безопасность и контроль трафика, а ещё ограничит доступ между контейнерами, минимизируя риски взлома. Общий принцип изоляции, как я его понял для себя: 
Контейнеры, которые подключены к одной сети, могут взаимодействовать друг с другом через IP-адреса или имена сервисов. Контейнеры, подключенные к разным сетям, не могут напрямую общаться. Даже если они находятся на одной хост-машине, Docker не разрешит им обмениваться данными, если они подключены к изолированным сетям.

